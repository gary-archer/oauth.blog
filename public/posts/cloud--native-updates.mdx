# Cloud Native OAuth

Previously I explained this blog's <a href='serverless-api-coding-model.mdx'>Serverless API Code Details</a> to complete the initial cloud deployment. Yet the API side of the architecture has some problems:

- It is locked in to AWS technology and its deployment options.
- The managed authorization server, API gateway and logging systems lack some essential features.
- The API technology works differently on development computers and in the cloud.

### Cloud Native Deployments

Having used a variety of deployments, I prefer the following default mix for the hosting of web and API components. Both of these are portable choices where you use the cloud provider's building blocks but can also run the same architecture on a development computer.

| Area | Portable Deployment Option |
| ---- | -------------------------- |
| Web Architecture | Cloud Content Delivery Network |
| API Architecture | Cloud Kubernetes Platform |

These days, cloud platforms enable you to run Kubernetes clusters without needing to perform the lower level work. For example, managed solutions deal with control plane high availability and keeping Kubernetes nodes up to date. You then use cloud networking, disk storage and compute resources and only need to operate on application level YAML resources.

### OAuth in Kubernetes

Cloud native enables you to take closer control over OAuth, in areas like identity data, token issuance, token translations, user authentication and security monitoring. You should be able to to improve your security capabilities and avoid technical limitations and blocking issues, to take full advantage of the architecture.

You can learn much more about combining OAuth and cloud native in the O'Reilly book that I wrote with my colleagues from Curity. The content provides a much deeper dive into OAuth and API first security. The code examples demonstrate various cloud native integrations and deployments that you can run on a development computer and then deploy to the cloud in the same way:

- [Cloud Native Data Security with OAuth](https://www.oreilly.com/library/view/cloud-native-data/9781098164874/)
- [Book Code Examples](https://github.com/curityio/cloud-native-oauth-security-examples)

You can implement many deeper requirements on the API side of the architecture, like the following essential security features:

- Platform features like workload identities, to enable secure connections with short-lived credentials.
- An authorization server that provides up-to-date security features for APIs and clients.
- An API gateway that supports plugins to enable token translations.
- A logging system with rich visualization and querying features for monitoring security events.

### Migrating APIs and Clients to Kubernetes

To optimize your future migration choices, write portable code regardless of technology. I can deploy all of the final APIs that I developed for this blog on Kubernetes, connect all of the final frontends, then deploy to any cloud or on-premise. An organization that follows this approach can keep its options open and plan many types of deployments, including multi-cloud. It can also use local clusters for some types of development and test environments, to save costs.

### Where Are We?

I briefly summarised the importance of designing your cloud deployments based on your requirements. Consider the capabilities that your APIs and clients need and the supporting components that will help you to meet them. Also aim for portable and future proof deployments. Ideally, ensure that you can run OAuth end to end flows in the same ways on development computers and in the cloud.

### Next

For a list of all blog posts see the <a href='index.mdx'>Index Page</a>.
